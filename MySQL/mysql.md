**MySql相关知识点&八股文**
=================
**1.** 执行一条 select 语句，期间发生了什么？  

总的来说过程分为2层：Server 层和存储引擎层，
* Server 层负责建立连接、分析和执行 SQL
* 存储引擎层负责数据的存储和提取
* 具体如下：
  * 连接管理；一般基于tcp建立连接，每当有一个客户端进程连接到服务器，服务器进程都会创建一个线程专门处理；当连接断开，该线程也不会被立即被销毁，方便下一个连接用。
  * 查询缓存
  * 解析器；构建语法树和检查语法，但是不会去查表或者字段存不存在。
  * 查询优化；生成好执行计划，找存储引擎取数据
  * 存储引擎取数据；一般以记录为单位。server层根据执行计划先向存储引擎取一条户数，判断是否符合where条件，如果符合返回客户端，否则继续向存储引擎索要下一条（当然不会立即返回，先发送到缓冲区，待满是一起返回）
***
**2.** MySql怎么解决长连接占用内存的问题？

有两种解决方式。
* 第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。
* 第二种，客户端主动重置连接。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。
***
**3.** InnoDB页是什么

由于innodb数据存磁盘上的，所以想要读取或者写入数据，内存和磁盘就得进行交互，而页就是交互的单位
***
**4.** MySQL 怎么知道 varchar(n) 实际占用数据的大小？  
在COMPACT行格式中，有一个变长字段长度列表，各个字段的真实占用字节按照列的顺序逆序存放；至于用一个字节还是2个字节，根据长度和字符集长度按照一定公式计算。  
如果所有列都不是变长数据类型或者值都是null，就不需要有变长字段列表了。  
注意：变长数据类型不光是varchar或者各种text类型，还跟字符集有关；例如比如一个char类型的列，但采用的是变长编码的字符集（如gbk,utf8）那么它的实际长度也会被存到变长字段长度列表中。
***
**5.** MySQL 的 NULL 值是怎么存放的？  
在COMPACT行格式中，有一个null值列表，将每一个允许存储null的列对应一个二进制位，二进制位按照列的顺序逆序排列；1表示该值为null，0表示该值不为null。  
如果表中没有存储null的列，则null值列表也就不存在了。
***
**6.** Innodb主键 生成策略  
不展开，不会自己google
***
**7.** 如果列溢出，mysql是怎么处理的
在COMPACT行格式中，该列只会存储前768个字节，后面用20个字节，存储存放溢出数据页的地址。  
在DYNAMIC和COMPRESSED行格式中，它们把所有数据都存放在溢出页里面，而记录列存放溢出页地址；COMPRESSED还会对页面进行压缩
***
**8.** MySql的InnoDB的三层B+树可以存储多少数据？
> 套路：  
> 第一步：说清楚行存储所占空间（记住一定说一些前提条件，比如存储行格式等）  
> 第二步：说清楚页的定义和页空间  
> 第三步：说清楚B+树建立的流程  
> 第四部：计算  

首先不同行格式，一行数据占用的空间也不一样；
我们假设使用的是compact行格式，不考虑变长字段列表和Null列表且只有一个主键为int类型的字段id，
则一行叶子结点一行数据占用大小的计算公式为：记录头信息（5字节）+ int(4字节)+隐藏列（13字节）= 22。
非叶子节点一行数据计算公式为：记录头信息（5字节）+ int(4字节)+指针（8字节）=17  。  
然后因为我们知道数据是存储磁盘的，当我们读取数据的时候，肯定不会直接从磁盘里面读，所以页就产生了。
将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，一页默认值为16k。页的一些公共字段总共占128个字节 。  
然后mysqlB+树是先从根页面添加数据，当根页面存储满之后，就会进行页分裂，此时根页面存储目录项，分裂出来的页面存储数据项；
如果是三层，则2层目录项一层数据项。  
最后我们总结一下；一个非叶子节点页面可以存储 16256/17约等于956目录项一个叶子结点可以存储738条数据；
则三层总计为956*956*738
***
**9.** 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？  
二叉树：随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。  
b树：B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。
B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
***
**11.** 聚簇索引和二级索引的定义  
聚簇索引：非叶子节点存放主键索引目录，叶子结点存放完整的用户记录（包含隐藏列）。  
二级索引：非叶子节点存放索引列+主键值+页号 ，叶子结点存放索引列+主键。注意：二级索引每找到一条符合的数据就进行回表(有mrr优化，具体在p173)。
***
**12.** mysql如何使用索引查找数据的  
根页面（固定地址）-> 非叶子节点（页内使用页目录进行二分查找）->叶子结点（页内使用页目录进行二分查找）
***
**13.** 索引使用（索引优化）
* 查看一个列或多个列（索引合并）是否使用索引就看能否形成高效的扫描区间。
  * 这里举一个正确的例子
    * 例如：select * from A where key > 100 假设key是个二级索引，形成扫描区间为（100，﹢∞），然后根据区间去扫描相对应的数据，最后进行回表查询。
  * 举一个错误的例子比如or的使用
    * 例如：select * from A where key > 100 or filed = "abc" 假设key是个二级索引,形成的区间就是（-∞，﹢∞）
  * 通过like左边%引出索引下推
    * like的话，由于索引都是有序排列，所以当%在左边的话就会无法使用索引，当然有一种特殊的场景，比如：select * from A where key > 'abc' and key like %uef；这种的话，key通过like是可以进行一定的筛选的，原因就是索引下推。
    * 索引下推是为了优化回表，所以索引下推只使用于二级索引
  * 索引合并
    * 一般情况下mysql都会选择一个索引形成一个扫描区间，但在一些特殊的情况会使用到多个索引进行合并。mysql有三种索引合并的类型，分别为：intersection合并 union合并和sort-union合并
* 说完单条后接着说一下连接查询原理和优化
  * mysql的连接原理就是嵌套循环连接法，所以在被驱动表建立合适的索引，减少被驱动表的扫描数据量至关重要。
* 说完上述后，引出explain查询
  * 当然，如果真的是个很复杂的查询，我们还是得借助explain。
  * 一般我们查看的字段有：
    * type：查询是访问的方法。下面是一些常见的访问方法
      * system：当表中只有一条数据并且该表使用的存储引擎（比如myisam）的统计数据是精确的，那么该表的访问方式就是system。
      * const：当我们根据主键或者唯一二级索引（不为Null）列与常数进行等值匹配时，对单表的访问方法就是const。
      * eq_ref：执行连接查询时，如果被驱动表是通过主键或者不允许存储null值的唯一二级索引列等值匹配的方式进行访问的，则该驱动表的访问方法就是eq_ref
      * ref：普通的二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方法就可能是ref。
      * ref_or_null：普通的二级索引列与常量进行等值匹配且该索引列可能为null时，那么访问的方法可能就是ref_or_null
      * index_merge：索引合并
      * rang：如果使用索引获取某些单点扫描区间的记录，那么就可能使用到range。
      * index：索引覆盖
    * possible_keys&key
      * 可能使用到的索引和实际使用到的索引
    * extra
      * using index 使用索引覆盖
      * using index condition 索引下推
      * using where 搜索条件需要再server层进行判断
      * using filesort 使用内存或磁盘进行排序
      * using temporary 使用临时表来执行查询

