**RocketMq八股文**
=================
**1.** rocketMQ为什么要用消费组，起什么作用？  
答：①：消息消费负载均衡 ②：故障容错 
***
**2.** RocketMQ同一个消费组内的消费者订阅量不同tag，会有问题吗？  
答：会出现丢消息的情况。（发现不相同tag，offset直接跳过非查找的tag，导致消息丢失）
***
**3.** RocketMQ 消费者拉取一批消息，其中部分消费失败了，偏移量怎样更新？  
答：rocketmq采用最小位点提交机制，例如消息消费线程池中的三个消费线程t1,t2,t3分别在处理消息偏移量1,2,3的消息，
由于是并发消费，如果t3线程将msg3先消费完成后，会向服务端提交msg1的偏移量。如果在此期间消费者发生重启，
则会导致重复消费。
***
**4.** 消息堆积了怎么办？  
答：增加相同topic的队列数或者再开一个topic进行消息迁移消费。
***
**5.** 如何让 RocketMQ 保证消息的顺序消费？  
答：生产者 设置将统一事务下的消息投放至同一个队列里面。消费者 并发模式改为顺序模式。
***
**6.**  RocketMq是push模型还是pull模型？
答：rocketmq不管是推模式还是拉模式底层都是拉模式，推模式也是在拉模式上做了一层封装。
***
**7.** RocketMq为什么采用主动拉取消息而不使用事件监听方式？  
如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在 Consumer 端堆积过多。
而 pull 的方式可以根据当前自身情况来 pull，不会造成过多的压力而造成瓶颈。所以采取了 pull 的方式。
***
**8.** 如何保证RocketMQ不丢失消息  
* 生产阶段：
  * 生产者通过网络发送消息给broker，当broker收到之后，将会返回确认响应信息给 Producer。
    所以生产者只要接收到返回的确认响应，就代表消息在生产阶段未丢失。当出现网络问题，我们可以设置合理的重试次数。
* Broker存储阶段：
  * 分为异步刷盘和同步刷盘，若想保证Broker端不丢消息，可以通过修改配置改为同步刷盘。
* 消费阶段：
  * 消费者从 broker 拉取消息，然后执行相应的业务逻辑。一旦执行成功，将会返回 ConsumeConcurrentlyStatus.CONSUME_SUCCESS 状态给 Broker。
    如果Broker未收到消费确认响应或收到其他状态，消费者下次还会再次拉取到该条消息，进行重试。这样的方式有效避免了消费者消费过程发生异常，或者消息在网络传输中丢失的情况。
***
**9.** RocketMq的存储机制了解吗？  
答：RocketMq采用文件系统存储消息，并采用顺序写写入消息，使用零拷贝发送消息，极大得保证了RocketMq的性能。
***
**10.** 零拷贝是什么？rocketmq是怎么实现的？  
* 零拷贝：
  * 简单来说就是减少【用户态与内核态的上下文切换】和【内存拷贝】的次数的方案。通常有2种：mmap + write和sendfile
* rocketmq是怎么实现的：
  * mmap + write + Page cache
